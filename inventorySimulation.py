'''
The program is written by:
Dahye Kim

The program is first written on:
24 Apr 2020

The program is last modified on:
1 May 2020

The program simulates the inventory system of Cantilever Umbrella, an Australian firm established on 1 Jan 2000
specialised in sales of umbrellas.

The program first reads through a text file, which informs the start date of the simulation, as well as the starting
stock and starting revenue of the input date. Before the calculation of the ending date, stock, and revenues, the
program first runs a series of in-built functions that check the validity of the values in the text file. If the text
file contains invalid input, the program runs with the default value accordingly. The end-user can also input the
defective rate, recurring frequency of the financial crisis cycle, as well as the number of years of simulation before
running the cal_stock_revenue() function. These variables are also checked and adjusted if necessary, before performing
the calculation.

To calculate the ending stock, ending revenue, and date at the end of the year simulation, cal_stock_revenue() function
takes in the startingValues from read_data() function and takes the following steps:

- Each year between the established year of the company (2000) until the end year of the simulation
(start_year + NO_YEAR_SIM) has its unique list called monthlySummaries. These lists are generated
by endYearTo2000Summary() function, and each contains twelve dictionaries. Each dictionary, referred as
singleMonthSummary returned by generateMonthlySummaries(), is the monthlySummary of each month in the year, which
includes each month's RRP and dailySales.

- Each monthlySummaries list returned by endYearTo2000Summary() is further refined by
monthlySaleAndDefectivesCalculator() function. The function loops through each singleMonthSummary dictionary within
monthlySummaries and calculates defectives generated from each month, sales of each months before and after defectives
sales. The list then removes all the monthlySummaries from the years before the starting year of the simulation.

- With the refined monthlySummaries generated by monthlySaleAndDefectivesCalculator(),
generateComprehensiveDailyReports() creates dictionaries called dailyReport to every single day within each year.
dailyReports has multiple key-value pairs including 'year', 'month', 'day', 'dailySale', 'RRP', 'defectivesToBeSold',
 and 'defectivesRemained'. The function returns a list of all the dailyReport generated.

- cal_stock_revenue() function then is calculates the starting revenue, ending revenue, starting stock,
ending stock, and accumulated revenue of each day, and records these values as key-value pairs in dailyReports generated
from generateComprehensiveDailyReports. Once the simulation ends, the dailyReport of the end date is extracted.
The year, month, day, endingStock and accumulated Revenue of this report are then recorded into a dictionary, which is
the final output of the cal_stock_revenue() function.

In the end, the program runs write_data() function with the dictionary generated by cal_stock_revenue(), to create a
new textfile 'AU_INV_END.txt' and record each value of each key from the dictionary.
'''


# 12 months in a year
months = [*range(1, 13)]
# months where RRP and sales does not need to be adjusted during the peak season
nonPeakMonths = [*range(3, 11)]
# months where RRP and sales need to be adjusted during the peak season
peakMonths = [1, 2, 11, 12]
monthsWith31Days = [1, 3, 5, 7, 8, 10, 12]
monthsWith30Days = [4, 6, 9, 11]

PER_DEF = 5
NO_YEAR_SIM = 3
CRIS_RECUR_FREQUENCY = 9

defaultNO_YEAR_SIM = 3

# if the NO_YEAR_SIM variable cannot be converted to a floating number, it could imply that the variable input is a
# string, which is an invalid data type. Therefore, the program will run with the default NO_YEAR_SIM variable 3.
try:
    float(NO_YEAR_SIM)
except:
    print('The number of years simulation variable is not a valid number.\n'
          'The program will run with default simulation variable 3.\n')
    NO_YEAR_SIM = defaultNO_YEAR_SIM

# if the difference between floated NO_YEAR_SIM and integer NO_YEAR_SIM is larger than zero, the variable must have
# decimal(s), since int() does not round up the number input. Therefore, if the simulation has decimals, the program
# will round NO_YEAR_SIM with round function.
if float(NO_YEAR_SIM) - int(NO_YEAR_SIM) > 0:
    NO_YEAR_SIM = round(NO_YEAR_SIM)
    print('The number of years simulation variable is has decimal point(s).\n'
          f'The program will run with its rounded integer {NO_YEAR_SIM}.\n')

# If the NO_YEAR_SIM variable is negative, the program will run with the default NO_YEAR_SIM.
elif NO_YEAR_SIM <= 0:
    print('The number of years simulation variable is invalid.\n'
          'The program will run with its default simulation variable 3.\n')
    NO_YEAR_SIM = defaultNO_YEAR_SIM
# If none of the conditions above are applied, NO_YEAR_SIM is retured as an integer.
else:
    NO_YEAR_SIM = int(NO_YEAR_SIM)


defaultPER_DEF = 5

# If the PER_DEF input is not convertible to float, it implies that the format of the input number is not string.
# Since defective rate does not necessarily need to be an integer, the program tries to convert the input
# PER_DEF into a floating number.
try: float(PER_DEF)
# If PER_DEF is not convertible to floating number, then the program takes the default PER_DEF variable 5.
except:
    print('The defective rate constant is not a valid number.\n'
          'The program will use the default defective rate 5%.\n')
    PER_DEF = defaultPER_DEF

# Defective rates can be zero.
# If the floated PER_DEF is negative, the program will run with the default PER_DEF value 5.
if float(PER_DEF) < 0:
    print('Defective rate entered is negative.\n'
          'The program will run with default defective rate 5%.\n')
    PER_DEF = defaultPER_DEF

# If the floated PER_DEF is higher or equal to 100, it implies that the number of defectives exceeds that of umbrellas.
# Therefore, the program will give out a warning message to let the end-user double check the input number, but
# the program still takes the input PER_DEF.
elif float(PER_DEF) >= 100:
    print('WARNING: the defective rate is very high.\n'
          'This defective rate implies that there are more defectives produced than the number of products sold.\n')

defaultCRIS_RECUR_FREQUENCY = 9

# If the CRIS_RECUR_FREQUENCY variable cannot be converted to integer, it could imply that the variable input is a
# string, which is an invalid format. Therefore, the program will run with the CRIS_RECUR_FREQUENCY variable 9.
try:
    int(CRIS_RECUR_FREQUENCY)
except:
    print('The global financial crisis reoccurring frequency is not a valid number.\n'
          'The program will use the default frequency index 9.\n')
    CRIS_RECUR_FREQUENCY = 9

# If the integer CRIS_RECUR_FREQUENCY is negative, the program takes the default CRIS_RECUR_FREQUENCY value 9.
if int(CRIS_RECUR_FREQUENCY) < 0:
    print('The global financial crisis reoccurring frequency is negative.\n'
      'The program will run with its default frequency index 9.\n')
    CRIS_RECUR_FREQUENCY = defaultCRIS_RECUR_FREQUENCY

# If the difference between floatedCRIS_RECUR_FREQUENCY and integer CRIS_RECUR_FREQUENCY is larger than zero,
# the variable must have decimals, since int function does not round up the number input. Therefore,
# If the simulation has decimals, the program will round CRIS_RECUR_FREQUENCY with round function and run with the
# output integer.
elif float(CRIS_RECUR_FREQUENCY)-int(CRIS_RECUR_FREQUENCY) > 0:
    CRIS_RECUR_FREQUENCY = round(CRIS_RECUR_FREQUENCY)
    print(f'The global financial crisis reoccurring frequency has decimal(s).\n'
          f'The program will run with its rounded integer {CRIS_RECUR_FREQUENCY}.\n')
else:
    CRIS_RECUR_FREQUENCY = int(CRIS_RECUR_FREQUENCY)

'''
The function leapYearIdentifer takes the current year as input and outputs boolean values.
If the year input is a leap year, it returns True, and otherwise False.
The function is built for calculate the number of days in a single simulation cycle,
as well as to identify the number of days in February of each year.
'''
def identifyLeapYear(year):
    #If the year parameter is dividable by 4 but not dividable by 100, or if the year is dividable by 400,
    #the year is a leap year. If so, the function returns True; otherwise False.
    if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
        return True
    else:
        return False

'''
The function disassembleDate() takes the date from the text file as a parameter and returns a tuple,
whose elements are year, month, and day, all in an integer format.
This function is also utilised in validateDateInput function later on.
'''
def disassembleDate(date):

    # The date parameter is converted into string format in order to be sliced into year, month and day.
    date=str(date)

    # year is the first four characters of the date string.
    year=int(date[0:4])
    # month is the fifth and sixth characters of the date string.
    month=int(date[4:6])
    # day is the rest of the date string.
    day=int(date[6:8])

    # the function returns year, month and day in a tuple.
    return (year,month,day)


'''
The function reassembleDate takes year, month and day as parameters and returns a date in yyyymmdd format.
This function is later utilised at dateValidation() function and at the end of cal_stock_rev() function.
'''
def reassembleDate(year,month,day):

    # Assuming that the year, month, and day inputs are integers, we convert all parameters into string variables to
    # concatenate them in yyyymmdd format.
    year=str(year)

    # If the month parameter is smaller than 10, then the month variable should have 0 before it when converted into
    # a string variable. Otherwise, the month variable is directly converted to a string without further changes.
    if month < 10:
        month = '0' + str(month)
    else:
        month = str(month)

    # Same the month variable - if the day variable is less than 0, then it should have a 0 before it when
    # converted into a string. Otherwise, the day variable is directly converted to a string without further changes.
    if day < 10: day = '0' + str(day)
    else: day = str(day)

    # adjusted year, month, and day variables are concatenated for generating reassembledDate variable.
    reassembledDate=year+month+day

    return reassembledDate

'''
The function validateDateInput takes the starting date of simulation from AU_INV_START.txt and checks if the date
input is in a correct format.

First, the function tries to converts the input date into an integer to check if the date input is an eight-digit integer.
The function also checks if the length of date input in string format is an eight-digit integer.
If these two conditions are not met, the function returns 20000101 as the default date to run in the cal_stock_rev()
function.

When these two conditions are met, it calls disassembleDate function to break down the input date into year, month,
and day. It runs a series of tests to check if the date input is the integer that can represent the months and days.

Finally, it calls reassembleDate function to reassemble all the year month and day variables after necessary adjustment.
If the input date and returned date are equal, the function returns the original date. Otherwise, it prints out a
message reminding the end-user that the program is utilising the new date generated.
'''
def validateDateInput(start_yearFromTextFile):

    # the function tries to convert the input date into integers. If the date is not convertible to integers,
    # it implies that the input could be string variable. Therefore, the function will return the default date,
    # 20000101, if it is not convertible to integers.
    try: int(start_yearFromTextFile)
    except:
        print('The input date value must be eight-digit integers in yyyymmdd format.\n'
              'The program will run with the default value of 20000101.\n')
        startDateAfterValidation = 20000101
        return startDateAfterValidation

    # If the length of the input date does not match yyyymmdd format, then the length of the date input should not
    # equal to 8. If that is the case, the function returns the default date, 20000101.
    if len(str(start_yearFromTextFile)) != 8:

        print('The format of date input is not correct.\n'
              'The corrent format of date input must be in yyyymmdd value.\n'
              'The program will run with the default value of 20000101.\n')
        startDateAfterValidation = 20000101
        return startDateAfterValidation

    # If the date is convertible to integer and it is in yyyymmdd format, the function breaks the date input down to
    # the year, month and day, to validate each element of date with a series of tests.
    else:

        # disassembleDate function generates a tuple consists of year, month, and day. disassembledDate[0] thus refers
        # to the year. If the year is not convertible to an integer, then the function returns 2000,
        # the default year value. Otherwise, the year is converted to an integer.
        disassembledDate = disassembleDate (start_yearFromTextFile)

        try:
            startYear = int(disassembledDate[0])
        except:
            print ('The input data type of the starting year must be an integer that is larger or equal to 2000.\n'
                  'The program will run with the default year value 2000.\n')
            startYear = '2000'

        # The established year of the company was 2000. Therefore, the program allows the minimum input year value of 2000.
        # If the input year is less than 2000, the program will run with the default year value, 2000.
        if startYear < 2000:
            print('The minimum year input of the program is 2000.\n'
                  'The input year is less than 2000.\n'
                  'The program will run with the default minimum year 2000.\n')
            startYear = 2000

        # If the year is convertible to an integer and is larger or equal to 2000, the year remains the same.
        else:
            startYear = startYear

        # disassembledDate[1] refers to the month. If the month is not convertible to an integer, the function
        # returns 1 (January) as the default month value. Otherwise, the month is converted to an integer.
        try:
            startMonth = int(disassembledDate[1])
        except:
            print('The input data type of the starting month must be a two-digit integer between 1 and 12.\n'
                  'The program will run with the default minimum month 01 (January).\n')
            startMonth = 1

        # the month input cannot be larger than 12 (December). If the input month is larger than 12, the function
        # returns the default maximum month value 12.
        if startMonth > 12:
            print('The maximum month value is 12.\n'
                  'The input month value is larger than the maximum value.\n'
                  'The program will run with the default maximum month 12 (December).\n')
            startMonth = 12

        # the month input cannot be smaller than 1 (January). If the input month is smaller than 1, the function
        # returns the default minimum value 1.
        elif startMonth < 1:
            print('The minimum month value is 1.\n '
                  'The input month value is smaller than the minimum value.\n'
                  'The program will run with the default minimum month 01 (January).\n')
            startMonth = 1

        # disassembledDate[2] refers to the day. If the day is not convertible to an integer, then the function
        # returns 1, the default day value. Otherwise, the day is converted to an integer.
        try:
            startDay = int(disassembledDate[2])
        except:
            print ('The input data type of the starting day must be a two-digit integer larger than 0.\n'
                  'The program will run with the default minimum day 01.\n')
            startDay = 1

        # the day input cannot be smaller than 1. If the input day is smaller than 1, the function returns the
        # default minimum value 1.
        if startDay < 1:
            print ('The possible smallest day value is 1.\n'
                  'The input day is smaller than the possible smallest value.\n'
                  'The program will run with the default minimum day 01.\n')
            startDay = 1

        # The maximum day input allowed depends on the month input.
        # If the validated month is in monthswith31Days, the maximum day input must be 31.
        # If the day input is larger than 31, the function returns the default maximum value 31.
        elif int(startMonth) in monthsWith31Days and startDay > 31:
            print ('The possible largest day value for the input month is 31.\n'
                  'The input day is larger than the possible largest value.\n'
                  'The program will run with the largest day value possible for the month 31.\n')
            startDay = 31

        # If the validated month is in monthswith30Days, the maximum day input must be 30.
        # If the day input is larger than 30, the function returns the default maximum value 30.
        elif int(startMonth) in monthsWith30Days and startDay > 30:
            print ('The possible largest day value for the input month is 30.\n'
                  'The input day is larger than the possible largest value.\n'
                  'The program will run with the largest day value possible for the month 30.\n')
            startDay = 30

        # If the validated month is 2 (February), the maximum day input depends on whether the year is a leap year.
        elif int(startMonth) == 2 and startDay > 28:

            # Therefore, the function calls indentifyLeapYear() function and test if the year input is a leap year.
            leapYearIndicator=identifyLeapYear(int(startYear))

            # If the leapYearIndicator is True, the maximum day input allowed is 29, and otherwise 28.
            # Depends on the year input, if the day input is larger than the maximum day input allowed, then the
            # function returns the valid maximum day accordingly.
            if leapYearIndicator == True and startDay > 29:
                print('The possible largest day value for the input month is 29.\n'
                  'The input day is larger than the possible largest value.\n'
                  'The program will run with the largest day value possible for the month 29.\n')
                startDay = 29

            elif leapYearIndicator == False and startDay > 28:
                print('The possible largest day value for the input month is 28.\n'
                      'The input day is larger than the possible largest value.\n'
                      'The program will run with the largest day value possible for the month 28.\n')
                startDay = 28

    # After validating each element of the input date, the function calls reassembleDate() to return the validated
    # date into a yyyymmdd format.
    startDateAfterValidation = int(reassembleDate(startYear,startMonth,startDay))

    # If the validated date is different from the original input date, the function prints a message reminding the
    # end-user that the date utilised for the simulation has changed.
    if startDateAfterValidation != int(start_yearFromTextFile):
        print(f'Before the adjustment, the faulty date input was {start_yearFromTextFile}.\n'
              f'After the adjustment, the date input for the program is {startDateAfterValidation}.\n')

    #The function finally returns the valid date in yyyymmdd format as the output.
    return startDateAfterValidation

'''
The function read_data() reads the data from the input file 'AU_INV_START.txt
and generates a dictionary with the relative keys-value pairs.

The function first checks whether the starting stock and revenue are valid values to run cal_stock_revenue() function.
Additionally, it calls validateDateInput() function to check if the input date is in a correct format.

After running through a series of checking processes, the function generates a dictionary with three keys -
'start_year', 'start_stock', and 'start_revenue' - and match the relevant values accordingly.

Finally, the function returns the dictionary generated to run cal_stock_revenue() function.
'''
def read_data():

    handle = open('AU_INV_START.txt')
    lines = handle.readlines()

    # After reading through each line in the text file, each line is appended into the list dateStockAndRevenue as a
    # string after stripping \n at the end.
    dateStockAndRevenue = [line.rstrip() for line in lines]

    # The second element of the list is the starting stock.
    # The function converts the stock into the floating variable to test whether the input number is a string. If so,
    # the function returns the default stock value, 1000.
    try:
        startingStock=int(dateStockAndRevenue[1])
        float(startingStock)
    except:
        print('The input data type of starting stock must be an integer.\n'
              'The program will run with the default starting stock value 1000.\n')
        startingStock = 1000

    # The stock number cannot be negative. Therefore, if the stock number is less than 0, the function returns the
    # default stock value, 1000.
    if startingStock < 0:
        print('The minimum stock value must be larger or equal to 0. \n'
              'The input stock value is less than 0. \n'
              'The program will run with the default minimum stock value 0.\n')
        startingStock = 0

    if float(startingStock) - int(startingStock) > 0:
        print('The stock value input is a floating number.\n'
              'The program will run with the rounded integer of the input value.\n')
        startingStock = round(startingStock)
    else: startingStock = int(startingStock)

    # The third element of the list is the starting revenue.
    # The function converts starting revenue into a floating number since the revenues are recorded with two decimals.
    # If the input value for revenue is a string, the value is not convertible to floating number.
    # If so, the function returns the default revenue value 0.
    try:
        startingRevenue = float(dateStockAndRevenue[2])
    except:
        print('The input data type of starting revenue must be either a floating number or an integer.\n'
              'The program will run with the default starting revenue 0.\n')
        startingRevenue = 0

    # The first element of the list dateStockAndRevenue is the starting date.
    # validateDateInput() function checks if the date input is valid and returns the adjusted date in yyyymmdd format
    # after a series of test.
    startingDate=validateDateInput(dateStockAndRevenue[0])

    # After checking each element in the list, the function generates a dictionary called startingValues with
    # respective key-value pairs. This dictionary is the value returned when the end-user runs the function read_data().
    startingValues = {'start_year': startingDate, \
                      'start_stock': startingStock, \
                      'start_revenue': startingRevenue}

    handle.close()

    return startingValues

from math import ceil

#the ceil function from math library is imported for rounding up daily sales and defectives
from math import ceil

'''
The function generateYearlySummary takes three parameters - the current year, initial RRP, and initial daily sale quantity.
It first generates a list of twelve dictionaries, each representing a single month in a year.
Each dictionary contains the number of days within the month (for calculating the inventories later on),
the up-to-date RRP and daily amount of sale, which is calculated based on the initial RRP and initial sale.

In the end, the function generates the list of each month of the input year.
'''
def generateYearlySummary (year, initialRRP, initialSale):

    #every singleMonthSummary dictionary generated by the for-loop below is appended to monthlySummary list.
    monthlySummaries = []

    # Each month in the months list is looped through in the for-loop: each month between January to December is
    # run in the loop, 12 loops in total.
    for individualMonth in months:

        # Each loop generates a dictionary called singleMonthSummary. The first key-value pair in the dictionary is the
        # 'month' to individual month from the months list.
        singleMonthSummary = {'year':year,'month': individualMonth}

        # If the individualMonth is July (7), the initial RRP and initial sale are adjusted because July 01 is the start
        # of a new financial year.
        # Initial RRP increases by 5% and initial sale increases by 10% every July.
        if individualMonth == 7:
            initialRRP = initialRRP * 1.05
            initialSale = initialSale * 1.1

        # New keys, 'RRP' and 'dailySale' are created.
        # If the individualMonth, the value to 'month' key, is in the list peakMonths, the initial RRP increases by 20%
        # and the initial sale increases by 35%.
        # Otherwise, initial sale and RRP remains the same.
        if singleMonthSummary['month'] in peakMonths:
            singleMonthSummary['RRP'] = initialRRP * 1.2
            singleMonthSummary['dailySale'] = initialSale * 1.35

        elif singleMonthSummary['month'] in nonPeakMonths:
            singleMonthSummary['RRP'] = initialRRP
            singleMonthSummary['dailySale'] = initialSale

        # The dictionary has a new key 'days' referring to the number of days in a month.
        # If the individualMonth, the value to 'month' key, is in the list monthsWith31Days
        # the value to 'days' key is 31.
        if singleMonthSummary['month'] in monthsWith31Days:
            singleMonthSummary['days'] = 31

        # If the individualMonth, the value to 'month' key, is in the list monthsWith30Days,
        # the value to 'days' key is 30.
        elif singleMonthSummary['month'] in monthsWith30Days:
            singleMonthSummary['days'] = 30

        # If the individual month is not in monthsWith30Days or monthsWith31Days, then the month must be February.
        # To calculate the number of days in February, the function calls identifyLeapYear().
        else:
            # leapYearIndicator is a boolean returned by identifyLeapYear() function. If the year input is a leap year,
            # it returns True. Otherwise, it returns false.
            leapYearIndicator = identifyLeapYear(year)

            # If leapYearIndicator equals to True, the number of days, the value to the 'days' key in singleMonthSummary
            # is 29. If False, the value is 28.
            if leapYearIndicator == True:
                singleMonthSummary['days'] = 29
            else:
                singleMonthSummary['days'] = 28

        # The dictionary generated representing individual month is appended to monthlySummaries list.
        # The function appends it to the list, in order to be referred back to by the next month.
        # E.g. The number of defectives generated by January must be referred back to by February since it impacts
        # the monthly revenue, and the number of new umbrellas sold.
        monthlySummaries.append(singleMonthSummary)

    return monthlySummaries

'''
The function endYearTo2000Summary() takes a single parameter - the current year.

First, the function calculates the initial years of the financial crisis, which becomes the reference point for checking
if the financial crisis occurs.

The function then calls generateYearlySummary() function and creates monthlySummaries for 2000. Since
we already know the RRP and daily sales quantity of January 2000, the values of 2000 are the reference point for
calculating those of the following years.

monthlySummaries2000 is then appended to a list, which is then referred back to by the following
years when calculating relevant values.

The function then runs a for loop between 2000 and the input year. During each loop, singleMonthSummary of each month
of each year between 2000 and the input year is created and appended to monthlySummariesFrom2000ToEndYear list.
Initial RRP and sales are adjusted if necessary when creating each monthlySummaries.

In the end, all the annualSummaryofMonthlyTotals created from the for-loops, is appended to allYearsSummary list.
The allYearsSummary list is the output of the function.
'''
def endYearTo2000Summary(year):

    # The financial crisis is divided into three phases -
    # Phase one is the first year of the outbreak (e.g. 2009).
    # During phase one, the initial RRP increases by 10% and the initial sales decrease by 20%.
    # Phase two is the second year of the outbreak (e.g. 2010).
    # During phase two, the initial RRP increases by 5% and the initial sales decrease by 10%.
    # Phase three is the third year of the outbreak (e.g. 2011).
    # During phase three, the initial RRP increases by 3%, and the initial sales decrease by 5%.

    # If the constant variable CRIS_RECUR_FREQUENCY is 9, then the first phase of the second crisis is 9 years after
    # 2011, which is 2020.
    # The second phase of the second crisis is 2021, and the third phase is 2022.
    # The first phase of the third crisis is 9 years after 2022, which is 2031.

    # In this pattern, each phase of second crisis outbreak could be presented as:
    # lastCrisisPhaseXyear + CRIS_RECUR_FREQUENCY + 2 (e.g. 2009 + 9 + 2 =2011)
    # The function thus assigns the sum of CRIS_RECUR_FREQUENCY and 2 as crisisRecurringFrequencyIndex.
    crisisYearInitialPhase = 2000 + CRIS_RECUR_FREQUENCY
    crisisYearPhaseTwo = 2001 + CRIS_RECUR_FREQUENCY
    crisisYearPhaseThree = 2002 + CRIS_RECUR_FREQUENCY
    crisisReccurringFrequencyIndex = CRIS_RECUR_FREQUENCY + 2

    # The RRP and daily sale of January in 200 was 705 and 36 respectively. Therefore, the initial RRP and sales were
    # 705/1.2  and 36/1.35.
    # generateYearlySummary() function takes three parameters as input - year, initial RRP, and initial sales.
    # generateYearlySummary() returns a list of twelve dictinaries, each representing each month of the input year
    # with information such as RRP, dailySale quantity.
    monthlySummaries2000 = generateYearlySummary(2000, 705 / 1.20, 36 / 1.35)
    # monthlySummariesFrom2000ToEndYear list will take every single monthlySummaries of each year between 2000 and the
    # input year, which is created by the for-loop below.
    monthlySummariesFrom2000ToEndYear = [month for month in monthlySummaries2000]

    # To generate monthlySummaries of years after 2000, the function runs a for-loop.
    for singleYear in range (2001, year+1):

        # To calculate initialRRP and initialSale of each year after 2000, the RRP and dailySale from last December
        # are extracted. The initialRRP and initialSale of next year is 0.8 of the RRP and 0.65 of the dailySale
        # from last December.
        initialRRP = monthlySummariesFrom2000ToEndYear[-1]['RRP']/1.20
        initialSale = monthlySummariesFrom2000ToEndYear[-1]['dailySale']/1.35

        # Except for the first year of crisis, other following years of crisis can be expressed with the
        # crisisRecurringFrequencyIndex.
        # E.g. 2020 = 2009 + 9 + 2 or 2008 = 2003 + 3 + 2 if CRIS_RECUR_FREQUENCY = 3.
        # Therefore, to test if the year input is a crisis year, we can simply subtract the year input to the relative
        # phase and check if the difference is dividable by the crisisRecurringFrequencyIndex:
        # (2020 - 2009) / (9 + 2) =1 -> second crisis phase ONE if happening every 9 years
        # (2021 - 2010) / (9 + 2) = 1 -> second crisis phase TWO if happening every 9 years
        # (2013 - 2003) / (3 + 2) = 2 -> third crisis phase ONE if happening every 3 years
        # (2014 - 2004) / (3 + 2) = 2  -> third crisis phase TWO if happening every 3 years.
        # However, (2006 - 2003) / (3 + 2) != 1, (2040 - 2009) / (9 + 2) != 1
        # As such, if the difference is dividable by crisisRecurringFrequencyIndex, the input year is a crisis year.
        if singleYear == crisisYearInitialPhase or (singleYear - crisisYearInitialPhase) % crisisReccurringFrequencyIndex == 0:
            # If the input year is the first crisis year first phase, or later crisis year and first phase, then the
            # initial RRP increases by 10% and sales decreases by 20%.
            initialRRP = initialRRP* 1.1
            initialSale = initialSale* 0.8

        elif singleYear == crisisYearPhaseTwo or (singleYear - crisisYearPhaseTwo) % crisisReccurringFrequencyIndex == 0:
            # If the input year is the second crisis year second phase, or later crisis year and second phase, then the
            # initial RRP increases by 5% and sales decreases by 10%.
            initialRRP = initialRRP* 1.05
            initialSale = initialSale*0.9

        elif singleYear == crisisYearPhaseThree or (singleYear - crisisYearPhaseThree) % crisisReccurringFrequencyIndex == 0:
            # If the input year is the third crisis year third phase, or later crisis year and third phase, then the
            # initial RRP increases by 3% and sales decreases by 5%.
            initialRRP = initialRRP * 1.03
            initialSale = initialSale * 0.95

            # If none of the conditions above are met, the year input is not a crisis year, and thus the initial RRP and
            # initial sales do not change.
        else:
            initialRRP = initialRRP
            initialSale = initialSale

        # After running through the test for financial crisis year, the function calls generateYearlySummary() with the
        # current year, initial RRP, and initial Sales,
        monthlySummaries = generateYearlySummary(singleYear,initialRRP,initialSale)

        # generateYearlySummary() returns a list of twelve dictionaries, each dictionary represents each month in the
        # input year. In order to append each singleMonthSummary to monthlySummariesFrom2000ToEndYear list, the
        # for-loop is utilised.
        for singeMonthSummary in monthlySummaries:
            monthlySummariesFrom2000ToEndYear.append(singeMonthSummary)

    # monthlySummariesFrom2000ToEndYear, which is the list of all the singleMonthSummary of years between 2000
    # and the input year is returned at the end of the function.
    # This list is called later when calculating defectives generated, as well as the net sales after defectives
    # from each month.
    return monthlySummariesFrom2000ToEndYear

'''
The function monthlySaleAndDefectivesCalculator() takes in the endYear of the simulation as the parameter and returns
monthlySummariesFrom2000ToEndYear list.

The function first calls endYearTo2000Summary() function in order to obtain the list of all monthlySummaries
between the year 2000 and the endYear. monthlySummaries is a list of dictionaries, each dictionary represents
one month. (e.g. If the year input for endYearTo2000Summary() is 2001, then 24 dictionaries are generated and
appended to monthlySummariesFrom2000ToEndYear list.)

Then it calculates the number of defectives generated in each month based on the monthly sales quantity and the
defective rate. Based on the quantity of defectives generated, net sales after defectives in each month is also
calculated. These values are all appended to the singleMonthSummary dictionary with respective keys.

*The number of defectives are calculated based on NETSALES after selling the defectives generated last month, but not
the potential sales*
*The refund policy is not considered.*

To ease the calculation process of each month's daily ending revenue, the price of defective umbrellas are
also calculated and appended to the dictionary.
After the new key-pair values are generated, each dictionary is then appended to monthlySummaries From2000ToEndYear
list. This list is the output of the function.
'''
def monthlySaleAndDefectivesCalculator(year):

    # monthlysummaries of each year between 2000 to the year input is generated and appended to a single list.
    monthlySummariesFrom2000ToEndYear = endYearTo2000Summary(year)

    # The for-loop loops through each monthlySummariesFrom2000ToEndYear. To obtain defectives to be sold at the start
    # of each month, the defectives generated from former month is necessary. Therefore, loop iterates calls
    # enumerate function, which indicates the position of each singleMonthSummary in monthlySummariesFrom2000ToEndYear.
    # singleMonthSummary is a dictionary representing each month of each year between 2000 and the input year. The
    # dictionary includes the current year, current month, current RRP and sales.
    for monthSummaryIndex, singleMonthSummary in enumerate(monthlySummariesFrom2000ToEndYear):

        # potentialSales is the sales before subtracting defectives generated from last month.
        # New key 'potentialSales' is generated.
        potentialSales = singleMonthSummary['dailySale'] * singleMonthSummary['days']
        singleMonthSummary['potentialSales'] = potentialSales

        # If the index of singleMonthSummary in the list is 0, the month must be Jan 2000. This is the only month
        # where there is no defectives generated from last month.
        if monthSummaryIndex == 0:
            # The defectives generated from this month is calculated based on the potential sales.
            singleMonthSummary['defectivesGenerated'] = potentialSales * PER_DEF * 0.01
            # The net sales equals to potential sales in January 2000.
            singleMonthSummary['realSaleAfterDefectives'] = potentialSales
            # 'defectivePrice' refers to the discounted RRP for selling defectives generated from last month.
            # In January 2000, no defectives must be sold and therefore the 'defectivePrice' is 0.
            # defectivePrice for each month is recorded for facilitating the calculation of ending revenue later on.
            singleMonthSummary['defectivePrice'] = 0

        # All other months other than January 2000
        else:
            # last monthlySummariesFrom2000ToEndYear list before the current month in the loop is the former month.
            formerMonth = monthlySummariesFrom2000ToEndYear[monthSummaryIndex - 1]
            # The net sales after selling the defectives generated from last month is recorded as 'realSaleAfterDefectives'
            singleMonthSummary['realSaleAfterDefectives'] = potentialSales - formerMonth['defectivesGenerated']
            # The defectivesGenerated from this month is calculated based on the net sales.
            singleMonthSummary['defectivesGenerated'] = singleMonthSummary['realSaleAfterDefectives'] * PER_DEF * 0.01
            # price for selling the defectives generated from former month is the former month's discounted RRP.
            singleMonthSummary['defectivePrice'] = formerMonth['RRP'] * 0.8

    # The function returns monthlySummariesFrom2000ToEndYear, which contains ALL the monthlySummary between 2000
    # and the year input.
    return monthlySummariesFrom2000ToEndYear

'''
generateComprehensiveDailyReports() function takes the startDate input as the single parameter.

First, the start date is disassembled with disassembleDate () function to obtain the startYear of the simulation.

Then, after calculating the end year of the simulation, the function invokes monthlySaleAndDefectivesCalculator().
This function generates a list of monthlySummary of each month from 2000 to endYear. MonthlySummary is a dictionary
representing each month between 2000 and the end year. Each dictionary consists of information such as RRP,
dailySale, defectivesGenerated, etc.

The function then runs through a for-loop for each singleMonthSummary and runs another for-loop within the each day
of the month. (e.g, if singleMonthSummary['days'] == 31, the for-loop runs in range (1, 31 + 1). As such, a
dailyReport dictionary for each day of the year between 2000 and the input year is created. Information such as
daily sales quantity and RRP is appended to the dailyReport dictionary to facilitate the calculation of daily
inventory and ending revenue. To calculate the ending revenue of each day later on, the dailyReport dictionary also
includes 'defectivesToBeSold' at the start of the day, as well as the 'defectivesRemained' at the end of the day.

The dailyReports of the days before startDate are all removed from comprehensiveDailyReports list.

In the end, each dailyReport dictionary generated is appended to comprehensiveDailyReports list, which is the output
of the function.
'''
def generateComprehensiveDailyReports(startDate):

    # disassembleDate() function creates a three-tuple with year, month, day, each in an integer format.
    startYear = disassembleDate(startDate)[0]
    startMonth = disassembleDate(startDate)[1]
    startDay = disassembleDate(startDate)[2]
    # The end year of the simulation is the sum of start year and the number of simulation run.
    endYear = startYear + NO_YEAR_SIM

    # comprehensiveDailyReports stores all the dailyReports that will be generated from the for loops below.
    comprehensiveDailyReports = []

    # montlySummariesFrom2000ToEndYear is a list composed of monthlySummary from each month between 2000 to endYear.
    monthlySummariesFrom2000ToEndYear = monthlySaleAndDefectivesCalculator(endYear)

    # The for-loop loops through each singleMonthSummary in monthlySummariesFrom2000ToEndYear. The dictionary
    # includes information on RRP, dailySale and the defectives generated from each month.
    for monthIndex, singleMonthSummary in enumerate(monthlySummariesFrom2000ToEndYear):
        # the for-loop runs through between range 1 and the maximum days of the month, which is the value to the key
        # 'days' in each singleMonthSummary. Each loop represents each day of the month.
        for singleDay in range(1, singleMonthSummary['days'] + 1):
            # Each loop creates a dailyReport, which is consists of numbers of key-value pairs, including
            # 'year', 'month', 'day', 'dailySale', and 'RRP', which later becomes helpful when calculating
            # ending revenue and ending stock of each year.
            dailyReport = {'year': singleMonthSummary['year'], \
                           'month': singleMonthSummary['month'], \
                           'day': singleDay,
                           'dailySale': singleMonthSummary['dailySale'], \
                           'RRP': singleMonthSummary['RRP'],
                           'defectivePrice': singleMonthSummary['defectivePrice']}

            # After adding new values for calculating daily ending inventories and revenues, each daily report is
            # appended to comprehensiveDailyReports.
            comprehensiveDailyReports.append(dailyReport)

            # Only January 2000 does not have any defectivesToBeSold at the start of each day. Therefore, the
            # 'defectivesToBeSold' at the start of the day 'defectivesRemained' at the end of the day is zero in
            # January 2000.
            if dailyReport['year'] == 2000 and dailyReport['month'] == 1:
                dailyReport['defectivesRemained'] = 0
                dailyReport['defectivesToBeSold'] = 0

            # Except for January 2000
            else:
                # If the day is the start day of each month
                if singleDay == 1:
                    # The 'defectivesToBeSold' at the start of the day is the 'defectivesGenerated' from last month.
                    dailyReport['defectivesToBeSold'] = \
                        monthlySummariesFrom2000ToEndYear[monthIndex - 1]['defectivesGenerated']

                # For all other days in the month
                else:
                    # with .index() function, we address the position of the dailyReport of the former month in
                    # comprehensiveDailyReports.
                    formerMonth = comprehensiveDailyReports.index(dailyReport) - 1
                    # The defectivesToBeSold at the start of each day is the defectivesRemained from the day before.
                    dailyReport['defectivesToBeSold'] = \
                        comprehensiveDailyReports[formerMonth]['defectivesRemained']
            # The 'defectivesRemained' at the end of the day is the difference between the defectivesToBeSold at the
            # start of the day, and the 'dailySale' quantity each day.
            dailyReport['defectivesRemained'] = dailyReport['defectivesToBeSold'] - dailyReport['dailySale']

            # If the defectivesGenerated from last month is sold out, 'defectivesRemained' is recorded as 0.
            if dailyReport['defectivesRemained'] <= 0:
                    dailyReport['defectivesRemained'] = 0
            # All the dailyReport before the start date of the simulation are removed.
            if dailyReport['year'] == startYear \
                    and dailyReport['month'] == startMonth \
                    and dailyReport['day'] == startDay:
                del comprehensiveDailyReports[:comprehensiveDailyReports.index(dailyReport)]

    # The function returns the list of all the dailyReports generated.
    return comprehensiveDailyReports

'''
cal_stock_revenue function takes one single parameter - the startingValues dictionary. The dictionary is generated by
read_data() function and it includes three key-value pairs - start_year, start_stock, and start_revenue.

The cal_stock_revenue first calls generateComprehensiveDailyReports() function to obtain the list consists of
dailyReports from the startDate to 31 December of endYear. The function then assigns the start_stock and start_revenue
to the first element in the list, which is the dailyReport of the startDate.

The function then runs a for-loop to loop through every single dailyReport in the comprehensiveDailyReports to
calculate starting revenue, ending revenue, ending stock, and the accumulated revenue of each day. The number of
defectives generated from the former month is crucial in the calculation of inventory and revenue.
When the relevant values of the endDate dailyReport is created,  all the rest of the daily reports that are unnecessary
for the final output are removed.

The function extracts starting revenue, ending date, and starting stock from the last dailyReport in
comprehensiveDailyReport. These values then are appended to a dictionary, the output of the function, with relevant
keys assigned.
'''
def cal_stock_revenue(startingValue):
    # assigning each values of the dictionary generated by read_data() function.
    startingStock = startingValue['start_stock']
    startingRevenue = startingValue['start_revenue']
    startingDate = startingValue['start_year']

    # disassembleDate() function deconstructs the startingDate and generates a three-tuple composed of year, month,
    # and day. startYear is, therefore, the first element of the tuple generated by disassembleDate(), followed
    # by the month and day.
    startYear=disassembleDate(startingDate)[0]
    startMonth = disassembleDate(startingDate)[1]
    startDay = disassembleDate(startingDate)[2]

    # The endYear is the sum of startYear and the simulation index, while the end month and the end day is the same as
    # the startMonth and startDay respectively.
    # These three variables are the break-point of the upcoming for-loop.
    endYear = startYear + NO_YEAR_SIM
    endMonth = startMonth
    endDay = startDay

    # generateComprehensiveDailyReports() returns a list of dailyReports dictionaries, whose first element is the
    # dailyReport of the start day of the simulation.
    comprehensiveDailyReports = generateComprehensiveDailyReports(startingDate)

    # The startingStock and startingRevenue is assigned to the first dailyReport of the comprehensiveDailyReports.
    comprehensiveDailyReports[0]['startingStock'] = startingStock
    comprehensiveDailyReports[0]['startingRevenue'] = startingRevenue

    # Each dailyReport in the comprehensiveDailyReports list is looped through.
    # enumerate function enables the function to identify each dailyReport with a dailyReportIndex.
    # In order to refer back to the day before (for calculating startingRevenue and startingStock of each day), the
    # dailyReportIndex becomes helpful since it indicates the position of the former day in comprehensiveDailyReports.
    for dailyReportIndex, dailyReport in enumerate(comprehensiveDailyReports):

        dailySale = dailyReport['dailySale']
        currentRRP = dailyReport['RRP']
        defectivePrice = dailyReport['defectivePrice']
        defectivesToBeSold = dailyReport['defectivesToBeSold']

        # Other than the first dailyReport, which has already the startingStock assigned, other dailyReport's
        # startingStock is the endingStock of the day before.
        # A new key 'startingStock' is generated for the dailyReport.
        if dailyReportIndex != 0:
            dailyReport['startingStock'] = comprehensiveDailyReports[dailyReportIndex-1]['endingStock']

        # If the defectivesToBeSold at the start of the day is larger or equal to the dailySale quantity,
        # the ending revenue of the day equals to the defectives sold (the dailySale) multiplied by the discounted
        # RRP (defectivePrice).
        # *Defectives returned from last month is assumed not to be counted in the inventory.*
        # The number of inventory therefore does not change since no new umbrellas are sold.
        if defectivesToBeSold >= dailySale:
            dailyReport['endingRevenue'] = dailySale * defectivePrice
            dailyReport['endingStock'] = dailyReport['startingStock']

        # if the defectivesToBeSold at the start of the day is less than dailySale but still remains,
        # The ending revenue of the day is composed of two parts:
        # (1) income from the rest of the defectives sold with discounted RRP,
        # (2) and the revenue from the new umbrellas sold with the current RRP.
        # The new umbrellas sold is the difference between the dailySale and the rest of the defectives.
        # The ending stock is only affected by new umbrellas sold.
        elif defectivesToBeSold < dailySale and defectivesToBeSold > 0:

            dailyReport['endingRevenue'] = defectivesToBeSold * defectivePrice + \
                                           (dailySale - defectivesToBeSold) * currentRRP
            dailyReport['endingStock'] = dailyReport['startingStock'] - (dailySale - defectivesToBeSold)

        # if the defectives are all sold out, the endingRevenue is the product between dailySale and current RRP.
        # The ending stock is the difference between the startingStock and the dailySale.
        else:
            dailyReport['endingRevenue'] = dailySale*currentRRP
            dailyReport['endingStock'] = dailyReport['startingStock'] - dailySale

        # The company restocks 600 umbrellas at the end of the day, if the ending stock is less than or equal to 400.
        # *The restock occurs only once a day. *
        if dailyReport['endingStock']<= 400:
            dailyReport['endingStock'] += 600

        # The accumulated revenue of the first daily report in the list is the sum of the endingRevenue and the
        # startingRevenue
        if dailyReportIndex == 0:
            dailyReport['accumulatedRevenue'] = dailyReport['endingRevenue'] + dailyReport['startingRevenue']

        # For all other dailyReports
        else:
            # the accumulated revenue of the day is the sum of the endingRevenue and the accumulatedRevenue from the day
            # before. startingRevenue of the day is the accumulatedRevenue from the day before.
            dailyReport['accumulatedRevenue'] = dailyReport['endingRevenue'] + \
                                                 comprehensiveDailyReports[dailyReportIndex - 1]['accumulatedRevenue']
            dailyReport['startingRevenue'] = comprehensiveDailyReports[dailyReportIndex - 1]['accumulatedRevenue']

        # If the year, month, and day value are equal the endYear, endMonth and endDay respectively, the rest of the
        # dailyReports in comprehensiveDailyReports are deleted and the loop breaks.
        if dailyReport['year'] == endYear \
                and dailyReport['month'] == endMonth \
                and dailyReport['day'] == endDay+1:
            del comprehensiveDailyReports[comprehensiveDailyReports.index(dailyReport):]
            break

    # The last dailyReport in comprehensiveDailyReports list is that of the endDate.
    # * The end_revenue and end_stock generated by the cal_stock_revenue() function are the starting stock and revenue
    # of the end_year (ending date) *
    # The endDate is reassembled into yyyymmdd format with reassembleDate() function.
    endDayReport = comprehensiveDailyReports[-1]
    endRevenue = round(endDayReport['startingRevenue'],2)
    endStock = ceil(endDayReport['startingStock'])
    endDate = reassembleDate(endYear, endMonth, endDay)

    # The function eventually returns the dictionary with three key-value pairs: end_year, end_stock, and end_revenue.
    # This dictionary is then utilised in write_data() function, which writes the dictionary into a text file.
    finalOutput = {'end_year': endDate, \
                   'end_stock': endStock,\
                   'end_revenue': endRevenue}

    return finalOutput

'''
write_data() function takes one parameter - the dictionary output from cal_stock_revenue() composed of three key-value
pairs. Each value of the key in this dictionary is written into a text file 'AU_INV_END.txt'.
'''
def write_data(endingValues):

    handle = open('AU_INV_END.txt', 'w+')

    for individualkey in endingValues.keys():
        handle.write(str(endingValues[individualkey])+'\n')

    handle.close()

startingValues = read_data()
endingValues = cal_stock_revenue(startingValues)
write_data(endingValues)
